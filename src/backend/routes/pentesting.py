"""
Endpoints de pentesting de Unburden
Maneja generación, actualización y gestión de reportes de pentesting
"""
import os
import logging
from datetime import datetime
from fastapi import APIRouter, HTTPException
from fastapi.responses import JSONResponse, FileResponse

from src.backend.models.schemas import ContentRequest
from src.backend.agent.agent_manager import (
    get_pentesting_processor,
    get_pentesting_file_path,
    get_pentesting_reports,
    get_chat_histories,
    get_processing_lock,
    handle_user_message
)
from src.backend.utils.utils import (
    filter_unwanted_tags
)
from src.backend.chat.chat_manager import (
    validate_session_id
)

logger = logging.getLogger(__name__)

router = APIRouter()


@router.post("/inicializar-pentesting/{chat_id}")
async def initialize_pentesting(chat_id: str):
    """
    Inicializa una sesión de pentesting.
    Registra la sesión y crea archivos vacíos para reporte y chat history.
    """
    try:
        if not validate_session_id(chat_id):
            raise HTTPException(status_code=400, detail="Invalid session ID")

        # Registrar ruta del reporte (crea el directorio automáticamente)
        pentesting_file_path = await get_pentesting_file_path(chat_id)

        # Inicializar reporte vacío si no existe
        if not os.path.exists(pentesting_file_path):
            timestamp = datetime.now().strftime('%Y-%m-%d %H:%M:%S')
            initial_report = f"""# Informe de Pentesting de Ciberseguridad

**Sesión iniciada**: {timestamp}
**Herramienta**: Unburden v.1
**Chat ID**: {chat_id}

## Actividades Registradas

_Esperando primera actividad..._

---
*Informe generado automáticamente por Unburden v.1*
"""
            with open(pentesting_file_path, "w", encoding="utf-8") as f:
                f.write(initial_report)

        logger.info(f"Pentesting session initialized for {chat_id}")
        logger.info(f"  - Report: {pentesting_file_path}")

        return JSONResponse({"message": "Pentesting session initialized"})

    except Exception as e:
        logger.error(f"Error initializing pentesting session {chat_id}: {e}")
        raise HTTPException(status_code=500, detail="Error initializing pentesting session")


@router.post("/generar-informe/{chat_id}")
async def generate_report(chat_id: str):
    """
    Genera un informe de pentesting profesional en formato Markdown.

    Flujo:
    1. Limpia el contexto del agente
    2. Carga el historial del chat
    3. Genera el informe con un único prompt que incluye el historial + instrucciones
    4. Guarda el informe en informe.md
    """
    try:
        if not validate_session_id(chat_id):
            raise HTTPException(status_code=400, detail="Invalid session ID")

        logger.info(f"[GEN] Starting report generation for {chat_id}")

        # 1. Limpiar contexto actual
        from src.backend.agent.agent_manager import agent, agent_context, clear_agent_context
        from src.backend.chat.chat_manager import ChatHistoryManager

        logger.info(f"[GEN] Clearing context...")
        clear_success = clear_agent_context()
        if not clear_success:
            raise HTTPException(status_code=500, detail="Agent not initialized")

        # 2. Obtener contenido del chat
        chat_manager = ChatHistoryManager()
        try:
            chat_content = chat_manager.load_chat_content(chat_id)
        except FileNotFoundError:
            raise HTTPException(
                status_code=404,
                detail=f"Chat {chat_id} not found. Asegúrate de que hay mensajes en el chat."
            )

        logger.info(f"[GEN] Chat content loaded: {len(chat_content)} chars")

        # 3. Generar el informe con el agente (un solo prompt con historial + tarea)
        try:
            if not agent or not agent_context:
                raise Exception("Agent not initialized")

            # Prompt que incluye el historial completo Y la tarea de generar el informe
            report_generation_prompt = f"""**PENTEST REPORT GENERATION MODE**

**CRITICAL INSTRUCTIONS:**
- Do NOT call any tools
- Do NOT execute any commands
- Do NOT use any MCP servers
- Do NOT repeat or copy the chat history into the report
- SUMMARIZE and SYNTHESIZE the information into a professional report

**YOUR TASK:**
Read the following chat history and generate a professional penetration testing report in Markdown format.

**CHAT HISTORY:**
{chat_content}

**REPORT REQUIREMENTS:**
Based ONLY on the information in the chat history above, generate a CONCISE, professional penetration testing report in Markdown format with the following structure:

# Penetration Testing Report

## Executive Summary
[Comprehensive overview of the testing activities and key findings]

## Scope and Methodology
- **Test Period**: [Extract from chat history]
- **Target Systems**: [ALL targets mentioned]
- **Tools and Techniques**: [ALL tools used]
- **Testing Approach**: [Based on actual activities]

## Detailed Findings and Evidence
[For EVERY significant activity in the chat history:]
### Finding #N - [Descriptive name]
- **Severity**: [Critical/High/Medium/Low]
- **Description**: [What was found/tested]
- **Technical Details**: [Real technical information]
- **Evidence**: [Actual command outputs and results]
- **Impact**: [Real-world implications]

## Risk Assessment
**Overall Risk Level**: [Based on actual findings]
[Detailed risk analysis for each finding]

## Recommendations
[Specific, actionable recommendations for each finding]

## Technical Appendix
### Complete Command History
```
[ALL commands executed in chronological order]
```

### Detailed Tool Outputs
```
[Complete outputs from tools, organized by activity]
```

---
*Report generated by Unburden v.1*
*Report Date: {chat_content[:50] if chat_content else 'N/A'}*

**IMPORTANT:** Generate the complete report now. Do NOT use tools. Use ONLY the information from the chat history above."""

            # Ejecutar el agente para generar el informe
            from llama_index.core.agent.workflow import AgentWorkflow
            handler = agent.run(user_msg=report_generation_prompt, ctx=agent_context)

            # Consumir el stream (no recolectamos eventos intermedios para evitar duplicación)
            async for event in handler.stream_events():
                pass  # Solo consumir eventos, no acumular

            # Obtener la respuesta final completa
            response = await handler
            report_content = str(response)
            processed_report = filter_unwanted_tags(report_content)

            if not processed_report or len(processed_report.strip()) < 100:
                raise Exception("Agent generated empty or invalid report")

            logger.info(f"[GEN] Report generated successfully: {len(processed_report)} chars")

        except Exception as agent_error:
            logger.error(f"[GEN] Agent report generation failed: {agent_error}")
            raise HTTPException(status_code=500, detail=f"Failed to generate report: {str(agent_error)}")

        # 4. Guardar el informe en informe.md
        pentesting_processor = get_pentesting_processor()
        await pentesting_processor.save_report_to_md(chat_id, processed_report)

        logger.info(f"[GEN] ✅ Report saved successfully to informe.md")
        return JSONResponse({"message": "Report generated successfully"})

    except HTTPException:
        raise
    except Exception as e:
        logger.error(f"[GEN] Error generating report: {e}")
        import traceback
        logger.error(f"Traceback: {traceback.format_exc()}")
        raise HTTPException(status_code=500, detail="Error generating report")


@router.get("/obtener-pentesting/{chat_id}")
async def get_pentesting_content(chat_id: str):
    """Obtiene el contenido del informe de pentesting"""
    try:
        if not validate_session_id(chat_id):
            raise HTTPException(status_code=400, detail="Invalid session ID")

        pentesting_processor = get_pentesting_processor()
        content = await pentesting_processor.extract_context_from_md(chat_id)
        return JSONResponse({"content": content})

    except Exception as e:
        logger.error(f"Error getting pentesting content for session {chat_id}: {e}")
        raise HTTPException(status_code=500, detail="Error retrieving pentesting content")


@router.post("/editar-informe/{chat_id}")
async def edit_report(chat_id: str, content_request: ContentRequest):
    """Edita el contenido del informe de pentesting"""
    try:
        if not validate_session_id(chat_id):
            raise HTTPException(status_code=400, detail="Invalid session ID")

        # Guardar contenido editado
        pentesting_processor = get_pentesting_processor()
        await pentesting_processor.save_report_to_md(chat_id, content_request.content)

        return JSONResponse({"message": "Report edited successfully"})

    except HTTPException:
        raise
    except Exception as e:
        logger.error(f"Error editing report for session {chat_id}: {e}")
        raise HTTPException(status_code=500, detail="Error editing report")



@router.get("/descargar-pentesting/{chat_id}")
async def download_pentesting_report(chat_id: str):
    """Descarga el informe de pentesting"""
    try:
        if not validate_session_id(chat_id):
            raise HTTPException(status_code=400, detail="Invalid session ID")

        pentesting_file_path = await get_pentesting_file_path(chat_id)

        if not os.path.exists(pentesting_file_path):
            raise HTTPException(status_code=404, detail="Pentesting report not found")

        filename = f"pentesting_{chat_id}.md"
        return FileResponse(
            pentesting_file_path,
            filename=filename,
            media_type='text/markdown'
        )

    except HTTPException:
        raise
    except Exception as e:
        logger.error(f"Error downloading pentesting report for session {chat_id}: {e}")
        raise HTTPException(status_code=500, detail="Error downloading pentesting report")



@router.post("/subir-informe/{chat_id}")
async def upload_report(chat_id: str, content_request: ContentRequest):
    """Sube un informe de pentesting"""
    try:
        if not validate_session_id(chat_id):
            raise HTTPException(status_code=400, detail="Invalid session ID")

        # Guardar contenido subido
        pentesting_processor = get_pentesting_processor()
        await pentesting_processor.save_report_to_md(chat_id, content_request.content)

        return JSONResponse({"message": "Report uploaded successfully"})

    except HTTPException:
        raise
    except Exception as e:
        logger.error(f"Error uploading report for session {chat_id}: {e}")
        raise HTTPException(status_code=500, detail="Error uploading report")



@router.delete("/borrar-pentesting/{chat_id}")
async def clear_pentesting_data(chat_id: str):
    """Borra los datos de pentesting de una sesión"""
    try:
        if not validate_session_id(chat_id):
            raise HTTPException(status_code=400, detail="Invalid session ID")

        # Borrar archivos de pentesting y chat
        pentesting_reports = get_pentesting_reports()
        chat_histories = get_chat_histories()
        processing_lock = get_processing_lock()

        async with processing_lock:
            if chat_id in pentesting_reports:
                pentesting_file = pentesting_reports[chat_id]
                if os.path.exists(pentesting_file):
                    os.remove(pentesting_file)
                del pentesting_reports[chat_id]

            if chat_id in chat_histories:
                chat_file = chat_histories[chat_id]
                if os.path.exists(chat_file):
                    os.remove(chat_file)
                del chat_histories[chat_id]

        return JSONResponse({"message": "Pentesting data cleared successfully"})

    except HTTPException:
        raise
    except Exception as e:
        logger.error(f"Error clearing pentesting data for session {chat_id}: {e}")
        raise HTTPException(status_code=500, detail="Error clearing pentesting data")
